# This formula installs letsencrypt as python pip package instead of git cloning the certbot repositoy
{% set letsencrypt = salt['pillar.get']('letsencrypt') %}

include:
  - letsencrypt.package


# We want to notice when a user has changed the list of SANs in the pillars
# Therefore we create a file with that list, if it changes we need to renew
letsencrypt_salt_change-notice_directory:
  file.directory:
    - name: /etc/letsencrypt/.saltstack
    - user: root
    - group: root
    - mode: 750
    - makedirs: True


# Iterate over the defined domains to request certificates for
{% for domain in letsencrypt['domains'] %}

# Parse the lists so we can watch it
letsencrypt_salt_change-notice-file_{{ domain['names'][0] }}:
  file.managed:
    - name: /etc/letsencrypt/.saltstack/{{ domain['names'][0] }}.list
    - user: root
    - group: root
    - mode: 400
    - contents: |
        ## DO NOT EDIT THIS FILE BY HAND !!! ##
        {%- for domain in domain['names'] %}
        {{ domain }}
        {%- endfor -%}

{#
# Check if there are already certs for this domain - if not, start initial creation
# There is no comfortable way in salt to check for multiple files as requirement for a cmd.run statement
# Also we dont want to renew all domains when we add one additional domain (as we can only request a specific
# domain for five times within a week or so
#}
letsencrypt_initial-request_{{ domain['names'][0] }}:
  cmd.wait:
    - user: root
    - group: root
    - shell: /bin/bash

    # Solve the chicken - egg problem: if there is nothing running on port 80, using webroot can not work
    # lsof -i :{ letsencrypt['check_port'] } will return exit status 0 if sth is listening and != zero if not
    {% set check_port_status = salt['cmd.run']('lsof -i ' + letsencrypt['check_port'] | string + ':80 2>&1 > /dev/null; echo $?') %}

    # Check the exit status of lsof - if its not 0, there is no service listening on { letsencrypt['check_port'] }
    {% if check_port_status != '0' %}
    # Make sure to remove the list file if the command fails so the next salt run will execute certbot again
    - name: |
        exec 2>&1
        /opt/letsencrypt/bin/letsencrypt {{ letsencrypt['standalone_arguments'] | join(' ') }} -d '{{ domain['names'] | join(',')}}' || {
          rm -v /etc/letsencrypt/.saltstack/{{ domain['names'][0] }}.list && exit 1
        }; {{ domain.get('hook', '') }}

    {% else %}
    - name: |
        exec 2>&1
        /opt/letsencrypt/bin/letsencrypt {{ letsencrypt['webroot_arguments'] | join(' ') }} --webroot -w {{ domain['webroot'] }} -d '{{ domain['names'] | join(',') }}' || {
          rm -v /etc/letsencrypt/.saltstack/{{ domain['names'][0] }}.list && exit 1
        }; {{ domain.get('hook', '') }}

    {% endif %}

    # We want this command to run, if:
    #   - The certfificate has never been requested before (/etc/letsencrypt/.saltstack/{{ domain['names'][0] }} would not exist)
    #   - The SANs are updated (/etc/letsencrypt/.saltstack/{{ domain['names'][0] }} would be updated too)
    - watch:
      - file: letsencrypt_salt_change-notice-file_{{ domain['names'][0] }}

    - require:
      - pip: letsencrypt_pip-package

{% endfor %}
